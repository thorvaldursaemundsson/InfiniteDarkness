{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","components/gamemaster/Battlemat.tsx","views/Battleview.tsx"],"names":["_possibleConstructorReturn","self","call","_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","_setPrototypeOf","p","_inherits","subClass","superClass","TypeError","prototype","create","constructor","value","writable","configurable","Battlemap","props","useState","onlySequencer","setOnlySequencer","onClick","icons","initialIcons","onNext","n","boardHeight","boardWidth","Sequencer","currentRound","setCurrentRound","currentSequence","setCurrentSequence","iconsBySequence","sort","a","b","sequence","maxSequence","length","nextRound","nextRoundAt","roundNumber","updateIcon","icon","updateIcons","index","_updateIcon","id","currentLife","filter","i","map","key","onChange","ic","remainingIcons","next","inputCss","width","IconTracker","setCurrentLife","applyLife","setApplyLife","newLife","symbol","style","type","title","e","parseInt","target","maxLife","Hexmat","mount","hexagonAngle","sideLength","hexHeight","hexRadius","hexRectangleHeight","hexRectangleWidth","state","outputData","currentIcons","currentIconsTurns","undefined","hexes","this","initializeBoard","canvas","iconAtHex","hasmoved","mouseStartX","mouseStartY","mouseEndX","mouseEndY","addEventListener","mouseEvent","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","Math","floor","screenX","screenY","ctx","getContext","clearRect","fillStyle","strokeStyle","lineWidth","drawBoard","drawHexagon","xR","yR","distanceBetweenPositions","startX","startY","speed","drawIconsOnBoard","findIconAtHex","setState","x1","y1","x2","y2","dx","abs","dy","z1","z2","dz","max","setVariables","ix","iy","sin","cos","canvasContext","getIconPosition","font","fillText","height","push","z","convertXyToXYZ","fill","str","beginPath","moveTo","lineTo","closePath","stroke","background","overflow","onContextMenu","preventDefault","ref","forceUpdate","React","Component","inputCssTiny","alpha","randId","rand","counter","random","Battleview","setWidth","setHeight","currentAddingIcon","setCurrentAddingIcon","currentAddingIconSqs","setCurrentAddingIconSqs","currentAddingIconSpeed","setCurrentAddingIconSpeed","currentAddingIconLife","setCurrentAddingIconLife","setIcons"],"mappings":"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","file":"static/js/6.f7ba12bb.chunk.js","sourcesContent":["import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import React, { CSSProperties, useState } from 'react';\r\n\r\ninterface IHex {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n}\r\n\r\ninterface IBattlemapState {\r\n    outputData: string;\r\n    currentIcons: Icon[];\r\n    currentIconsTurns: Icon | undefined;\r\n    hexes: IHex[]\r\n}\r\n\r\ninterface IBattlematProps {\r\n    boardHeight: number;\r\n    boardWidth: number;\r\n    initialIcons: Icon[];\r\n}\r\n\r\nexport interface Icon {\r\n    symbol: string;\r\n    startX: number;\r\n    startY: number;\r\n    id: string;\r\n    sequence: number;\r\n    speed: number;\r\n    maxLife: number;\r\n    currentLife: number;\r\n}\r\n\r\n\r\nexport const Battlemap: React.FC<IBattlematProps> = (props) => {\r\n    const [onlySequencer, setOnlySequencer] = useState(false);\r\n    if (onlySequencer === true)\r\n        return (<>\r\n            <button onClick={() => setOnlySequencer(false)}>View hexgrid</button><br />\r\n            <Sequencer icons={props.initialIcons} onNext={(n) => { }} />\r\n        </>);\r\n    else\r\n        return <>\r\n            <button onClick={() => setOnlySequencer(true)}>View only sequencer</button><br />\r\n            <Hexmat boardHeight={props.boardHeight} boardWidth={props.boardWidth} initialIcons={props.initialIcons} ></Hexmat>\r\n        </>;\r\n}\r\n\r\ninterface ISequencerProps {\r\n    icons: Icon[];\r\n    onNext: (next: Icon) => void;\r\n}\r\n\r\nconst Sequencer: React.FC<ISequencerProps> = ({ icons, onNext }) => {\r\n    const [currentRound, setCurrentRound] = useState(0);\r\n    const [currentSequence, setCurrentSequence] = useState(0);\r\n    const iconsBySequence = icons.sort((a, b) => b.sequence - a.sequence);\r\n    const maxSequence = icons.length >= 1 ? iconsBySequence[0].sequence : 0;\r\n    const nextRound = currentRound + 1;\r\n\r\n    const nextRoundAt = (roundNumber: number) => {\r\n        setCurrentSequence(maxSequence);\r\n        setCurrentRound(roundNumber);\r\n        if (iconsBySequence.length > 0) {\r\n            onNext(iconsBySequence[0]);\r\n        }\r\n    };\r\n\r\n    const next = () => {\r\n        const remainingIcons = iconsBySequence.filter(i => i.sequence < currentSequence);\r\n        if (remainingIcons.length > 0) {\r\n            setCurrentSequence(remainingIcons[0].sequence);\r\n            onNext(remainingIcons[0]);\r\n        }\r\n        else {\r\n            nextRoundAt(currentRound + 1);\r\n        }\r\n    };\r\n\r\n    const updateIcon = (icon: Icon) => {\r\n        const updateIcons = iconsBySequence;\r\n        for (var index in updateIcons) {\r\n            const _updateIcon = updateIcons[index];\r\n            if (_updateIcon.id === icon.id) {\r\n                _updateIcon.currentLife = icon.currentLife;\r\n            }\r\n        }\r\n    };\r\n\r\n    return <>\r\n        <button onClick={() => nextRoundAt(1)}>Begin/restart</button>\r\n        <h5>Round {currentRound}</h5>\r\n        <ul>\r\n            {iconsBySequence.filter(i => i.sequence <= currentSequence).map(i => {\r\n                return <li key={`bmsqeuencer_${i.id}`}><IconTracker onChange={ic => updateIcon(ic)} icon={i} />\r\n                    {i.sequence === currentSequence ? <button onClick={() => next()}>Done</button> : null}\r\n                </li>\r\n            })}\r\n        </ul>\r\n        <h5>Round {nextRound}</h5>\r\n        <ul>\r\n            {iconsBySequence.filter(i => i.sequence > currentSequence).map(i => {\r\n                return <li key={`bmsqeuencer_${i.id}`}><IconTracker onChange={ic => updateIcon(ic)} icon={i} /></li>\r\n            })}\r\n        </ul>\r\n    </>;\r\n}\r\n\r\nconst inputCss: CSSProperties = {\r\n    width: '60px'\r\n};\r\n\r\ninterface IIconTrackerProps {\r\n    icon: Icon;\r\n    onChange: (icon: Icon) => void;\r\n}\r\n\r\nconst IconTracker: React.FC<IIconTrackerProps> = ({ icon, onChange }) => {\r\n    const [currentLife, setCurrentLife] = useState(icon.currentLife);\r\n    const [applyLife, setApplyLife] = useState(0);\r\n\r\n    const updateIcon = (newLife: number) => {\r\n        setCurrentLife(newLife);\r\n        onChange({ ...icon, currentLife: newLife });\r\n    };\r\n\r\n    return <>\r\n        {icon.symbol} ({icon.sequence})\r\n        <input style={inputCss} type='text' title='life' value={currentLife} onChange={(e) => updateIcon(parseInt(e.target.value))} /> / {icon.maxLife} |\r\n        <input style={inputCss} type='text' title='damage' value={applyLife} onChange={(e) => setApplyLife(parseInt(e.target.value))} />\r\n        <button onClick={() => updateIcon(currentLife - applyLife)}>damage</button>\r\n    </>;\r\n}\r\n\r\n\r\n\r\nexport class Hexmat extends React.Component<IBattlematProps, IBattlemapState> {\r\n\r\n    mount: HTMLCanvasElement | undefined | null;\r\n    hexagonAngle: number = 0;\r\n    sideLength: number = 25;\r\n    hexHeight: number = 0;\r\n    hexRadius: number = 0;\r\n    hexRectangleHeight: number = 0;\r\n    hexRectangleWidth: number = 0;\r\n\r\n\r\n    constructor(props: Readonly<IBattlematProps>) {\r\n        super(props);\r\n        this.state = {\r\n            outputData: ':)',\r\n            currentIcons: props.initialIcons,\r\n            currentIconsTurns: undefined,\r\n            hexes: []\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        this.initializeBoard();\r\n\r\n        var canvas = this.mount;\r\n        if (canvas !== null && canvas !== undefined) {\r\n            let hasmoved = false;\r\n            let mouseStartX = 0;\r\n            let mouseStartY = 0;\r\n            let mouseEndX = 0;\r\n            let mouseEndY = 0;\r\n            let iconAtHex: Icon | undefined;\r\n            canvas.addEventListener(\"mousemove\", (mouseEvent) => {\r\n                var canvas = this.mount;\r\n                if (canvas !== null && canvas !== undefined) {\r\n                    const rect = canvas.getBoundingClientRect();\r\n                    const x = mouseEvent.clientX - rect.left;\r\n                    const y = mouseEvent.clientY - rect.top;\r\n                    mouseEndX = Math.floor(y / (this.hexHeight + this.sideLength));\r\n                    mouseEndY = Math.floor((x - (mouseEndX % 2) * this.hexRadius) / this.hexRectangleWidth);\r\n\r\n                    const screenX = mouseEndY * this.hexRectangleWidth + ((mouseEndX % 2) * this.hexRadius);\r\n                    const screenY = mouseEndX * (this.hexHeight + this.sideLength);\r\n\r\n                    var ctx = canvas.getContext('2d');\r\n                    if (ctx === null) return;\r\n                    ctx.clearRect(0, 0, this.props.boardWidth * 2 * this.sideLength, this.props.boardHeight * 2 * this.sideLength);\r\n\r\n\r\n                    ctx.fillStyle = \"#000000\";\r\n                    ctx.strokeStyle = \"#666666\";\r\n                    ctx.lineWidth = 1;\r\n                    this.drawBoard(ctx, this.props.boardWidth, this.props.boardHeight);\r\n\r\n                    if (mouseEndX >= 0 && mouseEndX < this.props.boardWidth && mouseEndY >= 0 && mouseEndY < this.props.boardHeight && ctx !== undefined) {\r\n                        ctx.strokeStyle = \"#FF0000\";\r\n                        ctx.lineWidth = 3;\r\n                        this.drawHexagon(ctx, screenX, screenY, false);\r\n                        ctx.strokeStyle = \"#666666\";\r\n                        ctx.lineWidth = 1;\r\n                    }\r\n                    if (iconAtHex !== undefined && ctx !== undefined) {\r\n                        for (var xR = 0; xR < this.props.boardWidth; ++xR) {\r\n                            for (var yR = 0; yR < this.props.boardHeight; ++yR) {\r\n                                if (this.distanceBetweenPositions(xR, yR, iconAtHex.startX, iconAtHex.startY) <= iconAtHex.speed) {\r\n                                    ctx.fillStyle = \"#9999FF\";\r\n                                    this.drawHexagon(\r\n                                        ctx,\r\n                                        xR * this.hexRectangleWidth + ((yR % 2) * this.hexRadius),\r\n                                        yR * (this.sideLength + this.hexHeight),\r\n                                        true//, `${x};${y}`\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    this.drawIconsOnBoard(ctx);\r\n                    hasmoved = true;\r\n                }\r\n            });\r\n\r\n            canvas.addEventListener(\"mousedown\", (mouseEvent) => {\r\n                hasmoved = false;\r\n                if (canvas !== null && canvas !== undefined) {\r\n                    const rect = canvas.getBoundingClientRect();\r\n                    const x = mouseEvent.clientX - rect.left;\r\n                    const y = mouseEvent.clientY - rect.top;\r\n                    mouseStartY = Math.floor(y / (this.hexHeight + this.sideLength));\r\n                    mouseStartX = Math.floor((x - (mouseStartY % 2) * this.hexRadius) / this.hexRectangleWidth);\r\n                    iconAtHex = this.findIconAtHex(mouseStartX, mouseStartY);\r\n                }\r\n            });\r\n            canvas.addEventListener(\"mouseup\", () => {\r\n                if (iconAtHex !== undefined && hasmoved === true) {\r\n                    let icons = this.state.currentIcons;\r\n                    for (var index in icons) {\r\n                        var ic = icons[index];\r\n                        if (ic.id === iconAtHex.id) {\r\n                            ic.startY = mouseEndX;\r\n                            ic.startX = mouseEndY;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this.setState({ currentIcons: icons });\r\n                    this.initializeBoard();\r\n                }\r\n\r\n                iconAtHex = undefined;\r\n                hasmoved = false;\r\n            });\r\n            canvas.addEventListener(\"mouseleave\", () => {\r\n                iconAtHex = undefined;\r\n            });\r\n        }\r\n    }\r\n\r\n    distanceBetweenPositions(x1: number, y1: number, x2: number, y2: number) {\r\n        const dx = Math.abs(x1 - x2);\r\n        const dy = Math.abs(y1 - y2);\r\n        if (dy === 0) return dx;\r\n        if (dy === 1) return dx + 1 - (dy % 2);\r\n        //const dz = (dx + Math.floor(dy * 0.5 + .5));\r\n        const z1 = 0 - (x1 + Math.floor(y1 * 0.5 + .5));\r\n        const z2 = 0 - (x2 + Math.floor(y2 * 0.5 + .5));\r\n        const dz = Math.abs(z1 - z2);\r\n\r\n        return dx + Math.max(dy, dz);\r\n    }\r\n\r\n    getIconPosition(icon: Icon) {\r\n        var x = this.hexRadius * 2 * (icon.startX + .25) + (icon.startY % 2 * this.hexRectangleWidth / 2);\r\n        var y = this.hexRectangleHeight * 0.75 * (icon.startY + 0) + this.hexRectangleHeight / 2;\r\n\r\n        return { x: x, y: y };\r\n    }\r\n    componentDidUpdate() {\r\n        if (this.props.initialIcons.length !== this.state.currentIcons.length)\r\n            this.setState({ currentIcons: this.props.initialIcons });\r\n        const canvas = this.mount;\r\n        if (canvas === null || canvas === undefined) {\r\n            return;\r\n        }\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) return;\r\n        this.initializeBoard();\r\n    }\r\n\r\n    initializeBoard() {\r\n        this.setVariables();\r\n        const canvas = this.mount;\r\n        if (canvas === null || canvas === undefined) {\r\n            return;\r\n        }\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) return;\r\n        ctx.clearRect(0, 0, this.props.boardWidth * 2 * this.sideLength, this.props.boardHeight * 2 * this.sideLength);\r\n\r\n\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.strokeStyle = \"#666666\";\r\n        ctx.lineWidth = 1;\r\n        this.drawBoard(ctx, this.props.boardWidth, this.props.boardHeight);\r\n        this.drawIconsOnBoard(ctx);\r\n        return ctx;\r\n    }\r\n    findIconAtHex(x: number, y: number): Icon | undefined {\r\n        for (var index in this.state.currentIcons) {\r\n            var icon = this.state.currentIcons[index];\r\n            var ix = icon.startX;\r\n            var iy = icon.startY;\r\n            if (x === ix && y === iy) return icon;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    setVariables() {\r\n        this.hexagonAngle = 0.523598776; // 30 degrees in radians\r\n        this.hexHeight = Math.sin(this.hexagonAngle) * this.sideLength;\r\n        this.hexRadius = Math.cos(this.hexagonAngle) * this.sideLength;\r\n        this.hexRectangleHeight = this.sideLength + 2 * this.hexHeight;\r\n        this.hexRectangleWidth = 2 * this.hexRadius;\r\n    }\r\n\r\n    drawIconsOnBoard(canvasContext: CanvasRenderingContext2D) {\r\n        for (var index in this.state.currentIcons) {\r\n            var icon = this.state.currentIcons[index];\r\n\r\n            const { x, y } = this.getIconPosition(icon);\r\n\r\n            if (this.state.currentIconsTurns === undefined) {\r\n            }\r\n            else if (icon.id === this.state.currentIconsTurns.id) {\r\n                canvasContext.fillStyle = 'red';\r\n                this.drawHexagon(canvasContext,\r\n                    icon.startX * this.hexRectangleWidth + ((icon.startY % 2) * this.hexRadius),\r\n                    icon.startY * (this.sideLength + this.hexHeight),\r\n                    true);\r\n            }\r\n\r\n            canvasContext.font = \"11px arial\";\r\n            canvasContext.fillStyle = \"black\";\r\n            canvasContext.fillText(`${icon.symbol}`, x, y);\r\n\r\n        }\r\n    }\r\n\r\n    convertXyToXYZ(x: number, y: number): string {\r\n        //const z = 0 - (x + Math.floor(y * 0.5 + .5));\r\n        return '';//`${x};${y};${z}`;//`${x};${y};${0 - (x + Math.floor(y * 0.5 + .5))}`;\r\n    }\r\n\r\n    drawBoard(ctx: CanvasRenderingContext2D, width: number, height: number) {\r\n\r\n        const hexes: IHex[] = [];\r\n\r\n        for (var x = 0; x < width; ++x) {\r\n            for (var y = 0; y < height; ++y) {\r\n                hexes.push({ x: x, y: y, z: 1 - (x + y) });\r\n                this.drawHexagon(\r\n                    ctx,\r\n                    x * this.hexRectangleWidth + ((y % 2) * this.hexRadius),\r\n                    y * (this.sideLength + this.hexHeight),\r\n                    false, this.convertXyToXYZ(x, y)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    drawHexagon(canvasContext: CanvasRenderingContext2D, x: number, y: number, fill: boolean, str: string = '') {\r\n        canvasContext.beginPath();\r\n        canvasContext.moveTo(x + this.hexRadius, y);\r\n        canvasContext.lineTo(x + this.hexRectangleWidth, y + this.hexHeight);\r\n        canvasContext.lineTo(x + this.hexRectangleWidth, y + this.hexHeight + this.sideLength);\r\n        canvasContext.lineTo(x + this.hexRadius, y + this.hexRectangleHeight);\r\n        canvasContext.lineTo(x, y + this.sideLength + this.hexHeight);\r\n        canvasContext.lineTo(x, y + this.hexHeight);\r\n        canvasContext.closePath();\r\n\r\n        if (str !== '') {\r\n            canvasContext.fillStyle = '#CCCCCC';\r\n            canvasContext.fillText(str, x + this.hexRadius / 2, y + this.hexRadius * 1.5);\r\n        }\r\n        if (fill) {\r\n            canvasContext.fill();\r\n        }\r\n        canvasContext.stroke();\r\n    }\r\n\r\n    render() {\r\n        return <table ><tbody>\r\n            <tr><td>\r\n                <div style={{ background: 'white', width: '650px', height: '600px', overflow: 'scroll' }}>\r\n                    <canvas height={this.props.boardHeight * this.sideLength * 1.5} width={this.props.boardWidth * this.sideLength * 1.8} onContextMenu={(e) => e.preventDefault()} ref={ref => (this.mount = ref)}></canvas>\r\n                </div></td>\r\n                <td>\r\n                    <Sequencer icons={this.props.initialIcons} onNext={(n) => { this.forceUpdate(); this.setState({ currentIconsTurns: n }); }} />\r\n                </td>\r\n            </tr></tbody></table>;\r\n    }\r\n}","import { CSSProperties } from '@material-ui/core/styles/withStyles';\r\nimport React, { useState } from 'react';\r\nimport { Battlemap, Icon } from '../components/gamemaster/Battlemat';\r\n\r\nconst inputCss: CSSProperties = {\r\n    width: '60px'\r\n};\r\n\r\nconst inputCssTiny: CSSProperties = {\r\n    width: '40px'\r\n};\r\n\r\nconst alpha = 'qwertyuiopasdfghjklzxcvbnm';\r\nconst randId = () => {\r\n    let rand = '';\r\n    for (var counter = 0; counter < 10; counter++) {\r\n        rand += alpha[Math.floor(Math.random() * alpha.length)];\r\n    }\r\n    return rand;\r\n}\r\n\r\nconst Battleview: React.FC = () => {\r\n    const [width, setWidth] = useState(18);\r\n    const [height, setHeight] = useState(15);\r\n    const [currentAddingIcon, setCurrentAddingIcon] = useState('');\r\n    const [currentAddingIconSqs, setCurrentAddingIconSqs] = useState(0);\r\n    const [currentAddingIconSpeed, setCurrentAddingIconSpeed] = useState(0);\r\n    const [currentAddingIconLife, setCurrentAddingIconLife] = useState(0);\r\n\r\n    const [icons, setIcons] = useState<Icon[]>([]);\r\n\r\n\r\n\r\n    const addIcon = () => {\r\n        setIcons([...icons, { symbol: currentAddingIcon, startX: icons.length, startY: 0, sequence: currentAddingIconSqs, speed: currentAddingIconSpeed, id: randId(), maxLife: currentAddingIconLife, currentLife: currentAddingIconLife }]);\r\n        setCurrentAddingIcon('');\r\n        setCurrentAddingIconSpeed(0);\r\n        setCurrentAddingIconSqs(0);\r\n        setCurrentAddingIconLife(0);\r\n    };\r\n\r\n    return <>\r\n        <input type='text' title='width' style={inputCssTiny} value={width} onChange={(e) => setWidth(parseInt(e.target.value))} />\r\n        <input type='text' title='height' style={inputCssTiny} value={height} onChange={(e) => setHeight(parseInt(e.target.value))} /> |\r\n        <input type='text' title='sequence' style={inputCssTiny} value={currentAddingIconSqs} onChange={(e) => setCurrentAddingIconSqs(parseInt(e.target.value))} />\r\n        <input type='text' title='speed' style={inputCssTiny} value={currentAddingIconSpeed} onChange={(e) => setCurrentAddingIconSpeed(parseInt(e.target.value))} />\r\n        <input type='text' title='life' style={inputCssTiny} value={currentAddingIconLife} onChange={(e) => setCurrentAddingIconLife(parseInt(e.target.value))} />\r\n        <input type='text' title='add icon' style={inputCss} value={currentAddingIcon} onChange={(e) => setCurrentAddingIcon(e.target.value)} />\r\n        <button onClick={() => addIcon()} >Add</button>\r\n\r\n        <br />\r\n        <Battlemap initialIcons={icons} boardHeight={height} boardWidth={width} />\r\n    </>;\r\n}\r\n\r\n\r\nexport default Battleview;"],"sourceRoot":""}