{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","components/gamemaster/Battlemat.tsx","views/Battleview.tsx"],"names":["_possibleConstructorReturn","self","call","_getPrototypeOf","o","Object","setPrototypeOf","getPrototypeOf","__proto__","_setPrototypeOf","p","_inherits","subClass","superClass","TypeError","prototype","create","constructor","value","writable","configurable","Battlemap","props","boardHeight","boardWidth","initialIcons","Sequencer","icons","onNext","useState","currentRound","setCurrentRound","currentSequence","setCurrentSequence","iconsBySequence","sort","a","b","sequence","maxSequence","length","nextRound","nextRoundAt","roundNumber","onClick","filter","i","map","key","id","symbol","remainingIcons","next","Hexmat","mount","hexagonAngle","sideLength","hexHeight","hexRadius","hexRectangleHeight","hexRectangleWidth","state","outputData","currentIcons","currentIconsTurns","undefined","hexes","this","initializeBoard","canvas","iconAtHex","hasmoved","mouseStartX","mouseStartY","mouseEndX","mouseEndY","addEventListener","mouseEvent","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","Math","floor","screenX","screenY","ctx","getContext","clearRect","fillStyle","strokeStyle","lineWidth","drawBoard","drawHexagon","xR","yR","distanceBetweenPositions","startX","startY","speed","drawIconsOnBoard","findIconAtHex","index","ic","setState","x1","y1","x2","y2","dx","abs","dy","z1","z2","dz","max","icon","setVariables","ix","iy","sin","cos","canvasContext","getIconPosition","font","fillText","width","height","push","z","convertXyToXYZ","fill","str","beginPath","moveTo","lineTo","closePath","stroke","style","background","overflow","onContextMenu","e","preventDefault","ref","n","forceUpdate","React","Component","inputCss","inputCssTiny","alpha","randId","rand","counter","random","Battleview","setWidth","setHeight","currentAddingIcon","setCurrentAddingIcon","currentAddingIconSqs","setCurrentAddingIconSqs","currentAddingIconSpeed","setCurrentAddingIconSpeed","setIcons","type","title","onChange","parseInt","target"],"mappings":"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","file":"static/js/5.0255d543.chunk.js","sourcesContent":["import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import React, { CSSProperties, useState } from 'react';\r\n\r\ninterface IHex {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n}\r\n\r\ninterface IBattlemapState {\r\n    outputData: string;\r\n    currentIcons: Icon[];\r\n    currentIconsTurns: Icon | undefined;\r\n    hexes: IHex[]\r\n}\r\n\r\ninterface IBattlemapWrapperState extends IBattlemapState {\r\n    isVisible: boolean;\r\n    currentEdit: Icon | undefined;\r\n}\r\n\r\ninterface IBattlematProps {\r\n    boardHeight: number;\r\n    boardWidth: number;\r\n    initialIcons: Icon[];\r\n}\r\n\r\ninterface Icon {\r\n    symbol: string;\r\n    startX: number;\r\n    startY: number;\r\n    id: string;\r\n    sequence: number;\r\n    speed: number;\r\n}\r\n\r\n\r\nexport const Battlemap: React.FC<IBattlematProps> = (props) => {\r\n    return <>\r\n\r\n        <Hexmat boardHeight={props.boardHeight} boardWidth={props.boardWidth} initialIcons={props.initialIcons} ></Hexmat>\r\n    </>;\r\n}\r\n\r\ninterface ISequencerProps {\r\n    icons: Icon[];\r\n    onNext: (next: Icon) => void;\r\n}\r\n\r\nconst Sequencer: React.FC<ISequencerProps> = ({ icons, onNext }) => {\r\n    const [currentRound, setCurrentRound] = useState(0);\r\n    const [currentSequence, setCurrentSequence] = useState(0);\r\n    const iconsBySequence = icons.sort((a, b) => b.sequence - a.sequence);\r\n    const maxSequence = icons.length >= 1 ? iconsBySequence[0].sequence : 0;\r\n    const nextRound = currentRound + 1;\r\n\r\n    const nextRoundAt = (roundNumber: number) => {\r\n        setCurrentSequence(maxSequence);\r\n        setCurrentRound(roundNumber);\r\n        if (iconsBySequence.length > 0) {\r\n            onNext(iconsBySequence[0]);\r\n        }\r\n    };\r\n\r\n    const next = () => {\r\n        const remainingIcons = iconsBySequence.filter(i => i.sequence < currentSequence);\r\n        if (remainingIcons.length > 0) {\r\n            setCurrentSequence(remainingIcons[0].sequence);\r\n            onNext(remainingIcons[0]);\r\n        }\r\n        else {\r\n            nextRoundAt(currentRound + 1);\r\n        }\r\n    };\r\n\r\n    return <>\r\n        <button onClick={() => nextRoundAt(1)}>Begin/restart</button>\r\n        <h5>Round {currentRound}</h5>\r\n        <ul>\r\n            {iconsBySequence.filter(i => i.sequence <= currentSequence).map(i => {\r\n                return <li key={`bmsqeuencer_${i.id}`}>{i.symbol} ({i.sequence})\r\n                {i.sequence === currentSequence ? <button onClick={() => next()}>Done</button> : null}\r\n                </li>\r\n            })}\r\n        </ul>\r\n        <h5>Round {nextRound}</h5>\r\n        <ul>\r\n            {iconsBySequence.filter(i => i.sequence > currentSequence).map(i => {\r\n                return <li key={`bmsqeuencer_${i.id}`}>{i.symbol} ({i.sequence})</li>\r\n            })}\r\n        </ul>\r\n    </>;\r\n}\r\n\r\n\r\ninterface IconEditorProps {\r\n    icon: Icon;\r\n    onChange: (i: Icon) => void;\r\n}\r\nconst inputCss: CSSProperties = {\r\n    width: '60px'\r\n};\r\nconst IconEditor: React.FC<IconEditorProps> = ({ icon, onChange }) => {\r\n    const [symbol, setSymbol] = useState(icon.symbol);\r\n    const [speed, setSpeed] = useState(icon.speed);\r\n    const [sequence, setSequence] = useState(icon.sequence);\r\n    return <>\r\n        Symbol: <input type='text' style={inputCss} value={symbol} onChange={(e) => setSymbol(e.target.value)} /><br />\r\n        Speed: <input type='text' style={inputCss} value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} /><br />\r\n        Sequence: <input type='text' style={inputCss} value={sequence} onChange={(e) => setSequence(parseInt(e.target.value))} /><br />\r\n        <button onClick={() => onChange({ ...icon, symbol: symbol, speed: speed, sequence: sequence })}>Save</button>\r\n\r\n    </>;\r\n}\r\n\r\nexport class Hexmat extends React.Component<IBattlematProps, IBattlemapState> {\r\n\r\n    mount: HTMLCanvasElement | undefined | null;\r\n    hexagonAngle: number = 0;\r\n    sideLength: number = 25;\r\n    hexHeight: number = 0;\r\n    hexRadius: number = 0;\r\n    hexRectangleHeight: number = 0;\r\n    hexRectangleWidth: number = 0;\r\n\r\n\r\n    constructor(props: Readonly<IBattlematProps>) {\r\n        super(props);\r\n        this.state = {\r\n            outputData: ':)',\r\n            currentIcons: props.initialIcons,\r\n            currentIconsTurns: undefined,\r\n            hexes: []\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        this.initializeBoard();\r\n\r\n        var canvas = this.mount;\r\n        if (canvas !== null && canvas !== undefined) {\r\n            let hasmoved = false;\r\n            let mouseStartX = 0;\r\n            let mouseStartY = 0;\r\n            let mouseEndX = 0;\r\n            let mouseEndY = 0;\r\n            let iconAtHex: Icon | undefined;\r\n            canvas.addEventListener(\"mousemove\", (mouseEvent) => {\r\n                var canvas = this.mount;\r\n                if (canvas !== null && canvas !== undefined) {\r\n                    const rect = canvas.getBoundingClientRect();\r\n                    const x = mouseEvent.clientX - rect.left;\r\n                    const y = mouseEvent.clientY - rect.top;\r\n                    mouseEndX = Math.floor(y / (this.hexHeight + this.sideLength));\r\n                    mouseEndY = Math.floor((x - (mouseEndX % 2) * this.hexRadius) / this.hexRectangleWidth);\r\n\r\n                    const screenX = mouseEndY * this.hexRectangleWidth + ((mouseEndX % 2) * this.hexRadius);\r\n                    const screenY = mouseEndX * (this.hexHeight + this.sideLength);\r\n\r\n                    var ctx = canvas.getContext('2d');\r\n                    if (ctx === null) return;\r\n                    ctx.clearRect(0, 0, this.props.boardWidth * 2 * this.sideLength, this.props.boardHeight * 2 * this.sideLength);\r\n\r\n\r\n                    ctx.fillStyle = \"#000000\";\r\n                    ctx.strokeStyle = \"#666666\";\r\n                    ctx.lineWidth = 1;\r\n                    this.drawBoard(ctx, this.props.boardWidth, this.props.boardHeight);\r\n\r\n                    if (mouseEndX >= 0 && mouseEndX < this.props.boardWidth && mouseEndY >= 0 && mouseEndY < this.props.boardHeight && ctx !== undefined) {\r\n                        ctx.strokeStyle = \"#FF0000\";\r\n                        ctx.lineWidth = 3;\r\n                        this.drawHexagon(ctx, screenX, screenY, false);\r\n                        ctx.strokeStyle = \"#666666\";\r\n                        ctx.lineWidth = 1;\r\n                    }\r\n                    if (iconAtHex !== undefined && ctx !== undefined) {\r\n                        for (var xR = 0; xR < this.props.boardWidth; ++xR) {\r\n                            for (var yR = 0; yR < this.props.boardHeight; ++yR) {\r\n                                if (this.distanceBetweenPositions(xR, yR, iconAtHex.startX, iconAtHex.startY) <= iconAtHex.speed) {\r\n                                    ctx.fillStyle = \"#9999FF\";\r\n                                    this.drawHexagon(\r\n                                        ctx,\r\n                                        xR * this.hexRectangleWidth + ((yR % 2) * this.hexRadius),\r\n                                        yR * (this.sideLength + this.hexHeight),\r\n                                        true//, `${x};${y}`\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    this.drawIconsOnBoard(ctx);\r\n                    hasmoved = true;\r\n                }\r\n            });\r\n\r\n            canvas.addEventListener(\"mousedown\", (mouseEvent) => {\r\n                hasmoved = false;\r\n                if (canvas !== null && canvas !== undefined) {\r\n                    const rect = canvas.getBoundingClientRect();\r\n                    const x = mouseEvent.clientX - rect.left;\r\n                    const y = mouseEvent.clientY - rect.top;\r\n                    mouseStartY = Math.floor(y / (this.hexHeight + this.sideLength));\r\n                    mouseStartX = Math.floor((x - (mouseStartY % 2) * this.hexRadius) / this.hexRectangleWidth);\r\n                    iconAtHex = this.findIconAtHex(mouseStartX, mouseStartY);\r\n                }\r\n            });\r\n            canvas.addEventListener(\"mouseup\", () => {\r\n                if (iconAtHex !== undefined && hasmoved === true) {\r\n                    let icons = this.state.currentIcons;\r\n                    for (var index in icons) {\r\n                        var ic = icons[index];\r\n                        if (ic.id === iconAtHex.id) {\r\n                            ic.startY = mouseEndX;\r\n                            ic.startX = mouseEndY;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this.setState({ currentIcons: icons });\r\n                    this.initializeBoard();\r\n                }\r\n\r\n                iconAtHex = undefined;\r\n                hasmoved = false;\r\n            });\r\n            canvas.addEventListener(\"mouseleave\", () => {\r\n                iconAtHex = undefined;\r\n            });\r\n        }\r\n    }\r\n\r\n    distanceBetweenPositions(x1: number, y1: number, x2: number, y2: number) {\r\n        const dx = Math.abs(x1 - x2);\r\n        const dy = Math.abs(y1 - y2);\r\n        if (dy === 0) return dx;\r\n        if (dy === 1) return dx + 1 - (dy % 2);\r\n        //const dz = (dx + Math.floor(dy * 0.5 + .5));\r\n        const z1 = 0 - (x1 + Math.floor(y1 * 0.5 + .5));\r\n        const z2 = 0 - (x2 + Math.floor(y2 * 0.5 + .5));\r\n        const dz = Math.abs(z1 - z2);\r\n\r\n        return dx + Math.max(dy, dz);\r\n    }\r\n\r\n    getIconPosition(icon: Icon) {\r\n        var x = this.hexRadius * 2 * (icon.startX + .25) + (icon.startY % 2 * this.hexRectangleWidth / 2);\r\n        var y = this.hexRectangleHeight * 0.75 * (icon.startY + 0) + this.hexRectangleHeight / 2;\r\n\r\n        return { x: x, y: y };\r\n    }\r\n    componentDidUpdate() {\r\n        if (this.props.initialIcons.length !== this.state.currentIcons.length)\r\n            this.setState({ currentIcons: this.props.initialIcons });\r\n        const canvas = this.mount;\r\n        if (canvas === null || canvas === undefined) {\r\n            return;\r\n        }\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) return;\r\n        this.initializeBoard();\r\n    }\r\n\r\n    initializeBoard() {\r\n        this.setVariables();\r\n        const canvas = this.mount;\r\n        if (canvas === null || canvas === undefined) {\r\n            return;\r\n        }\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) return;\r\n        ctx.clearRect(0, 0, this.props.boardWidth * 2 * this.sideLength, this.props.boardHeight * 2 * this.sideLength);\r\n\r\n\r\n        ctx.fillStyle = \"#000000\";\r\n        ctx.strokeStyle = \"#666666\";\r\n        ctx.lineWidth = 1;\r\n        this.drawBoard(ctx, this.props.boardWidth, this.props.boardHeight);\r\n        this.drawIconsOnBoard(ctx);\r\n        return ctx;\r\n    }\r\n    findIconAtHex(x: number, y: number): Icon | undefined {\r\n        for (var index in this.state.currentIcons) {\r\n            var icon = this.state.currentIcons[index];\r\n            var ix = icon.startX;\r\n            var iy = icon.startY;\r\n            if (x === ix && y === iy) return icon;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    setVariables() {\r\n        this.hexagonAngle = 0.523598776; // 30 degrees in radians\r\n        this.hexHeight = Math.sin(this.hexagonAngle) * this.sideLength;\r\n        this.hexRadius = Math.cos(this.hexagonAngle) * this.sideLength;\r\n        this.hexRectangleHeight = this.sideLength + 2 * this.hexHeight;\r\n        this.hexRectangleWidth = 2 * this.hexRadius;\r\n    }\r\n\r\n    drawIconsOnBoard(canvasContext: CanvasRenderingContext2D) {\r\n        for (var index in this.state.currentIcons) {\r\n            var icon = this.state.currentIcons[index];\r\n\r\n            const { x, y } = this.getIconPosition(icon);\r\n\r\n            if (this.state.currentIconsTurns === undefined) {\r\n            }\r\n            else if (icon.id === this.state.currentIconsTurns.id) {\r\n                canvasContext.fillStyle = 'red';\r\n                this.drawHexagon(canvasContext,\r\n                    icon.startX * this.hexRectangleWidth + ((icon.startY % 2) * this.hexRadius),\r\n                    icon.startY * (this.sideLength + this.hexHeight),\r\n                    true);\r\n            }\r\n\r\n            canvasContext.font = \"11px arial\";\r\n            canvasContext.fillStyle = \"black\";\r\n            canvasContext.fillText(`${icon.symbol}`, x, y);\r\n\r\n        }\r\n    }\r\n\r\n    convertXyToXYZ(x: number, y: number): string {\r\n        return `${x};${y};${0 - (x + Math.floor(y * 0.5 + .5))}`;\r\n    }\r\n\r\n    drawBoard(ctx: CanvasRenderingContext2D, width: number, height: number) {\r\n\r\n        const hexes: IHex[] = [];\r\n\r\n        for (var x = 0; x < width; ++x) {\r\n            for (var y = 0; y < height; ++y) {\r\n                hexes.push({ x: x, y: y, z: 1 - (x + y) });\r\n                this.drawHexagon(\r\n                    ctx,\r\n                    x * this.hexRectangleWidth + ((y % 2) * this.hexRadius),\r\n                    y * (this.sideLength + this.hexHeight),\r\n                    false, this.convertXyToXYZ(x, y)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    drawHexagon(canvasContext: CanvasRenderingContext2D, x: number, y: number, fill: boolean, str: string = '') {\r\n        canvasContext.beginPath();\r\n        canvasContext.moveTo(x + this.hexRadius, y);\r\n        canvasContext.lineTo(x + this.hexRectangleWidth, y + this.hexHeight);\r\n        canvasContext.lineTo(x + this.hexRectangleWidth, y + this.hexHeight + this.sideLength);\r\n        canvasContext.lineTo(x + this.hexRadius, y + this.hexRectangleHeight);\r\n        canvasContext.lineTo(x, y + this.sideLength + this.hexHeight);\r\n        canvasContext.lineTo(x, y + this.hexHeight);\r\n        canvasContext.closePath();\r\n\r\n        if (str !== '') {\r\n            canvasContext.fillStyle = '#CCCCCC';\r\n            canvasContext.fillText(str, x + this.hexRadius / 2, y + this.hexRadius * 1.5);\r\n        }\r\n        if (fill) {\r\n            canvasContext.fill();\r\n        }\r\n        canvasContext.stroke();\r\n    }\r\n\r\n    render() {\r\n        return <table ><tbody>\r\n            <tr><td>\r\n                <div style={{ background: 'white', width: '650px', height: '600px', overflow: 'scroll' }}>\r\n                    <canvas height={this.props.boardHeight * this.sideLength * 1.5} width={this.props.boardWidth * this.sideLength * 1.8} onContextMenu={(e) => e.preventDefault()} ref={ref => (this.mount = ref)}></canvas>\r\n                </div></td>\r\n                <td>\r\n                    <Sequencer icons={this.props.initialIcons} onNext={(n) => { this.forceUpdate(); this.setState({ currentIconsTurns: n }); }} />\r\n                </td>\r\n            </tr></tbody></table>;\r\n    }\r\n}","import { CSSProperties } from '@material-ui/core/styles/withStyles';\r\nimport React, { useState } from 'react';\r\nimport { Battlemap } from '../components/gamemaster/Battlemat';\r\n\r\nconst inputCss: CSSProperties = {\r\n    width: '60px'\r\n};\r\n\r\nconst inputCssTiny: CSSProperties = {\r\n    width: '40px'\r\n};\r\n\r\ninterface Icon {\r\n    symbol: string;\r\n    startX: number;\r\n    startY: number;\r\n    id: string;\r\n    sequence: number;\r\n    speed: number;\r\n}\r\nconst alpha = 'qwertyuiopasdfghjklzxcvbnm';\r\nconst randId = () => {\r\n    let rand = '';\r\n    for (var counter = 0; counter < 10; counter++) {\r\n        rand += alpha[Math.floor(Math.random() * alpha.length)];\r\n    }\r\n    return rand;\r\n}\r\n\r\nconst Battleview: React.FC = () => {\r\n    const [width, setWidth] = useState(18);\r\n    const [height, setHeight] = useState(15);\r\n    const [currentAddingIcon, setCurrentAddingIcon] = useState('');\r\n    const [currentAddingIconSqs, setCurrentAddingIconSqs] = useState(0);\r\n    const [currentAddingIconSpeed, setCurrentAddingIconSpeed] = useState(0);\r\n    const [icons, setIcons] = useState<Icon[]>([]);\r\n\r\n\r\n\r\n    const addIcon = () => {\r\n        setIcons([...icons, { symbol: currentAddingIcon, startX: icons.length, startY: 0, sequence: currentAddingIconSqs, speed: currentAddingIconSpeed, id: randId() }]);\r\n        setCurrentAddingIcon('');\r\n        setCurrentAddingIconSpeed(0);\r\n        setCurrentAddingIconSqs(0);\r\n    };\r\n\r\n    return <>\r\n        <input type='text' title='width' style={inputCssTiny} value={width} onChange={(e) => setWidth(parseInt(e.target.value))} />\r\n        <input type='text' title='height' style={inputCssTiny} value={height} onChange={(e) => setHeight(parseInt(e.target.value))} /> |\r\n        <input type='text' title='sequence' style={inputCssTiny} value={currentAddingIconSqs} onChange={(e) => setCurrentAddingIconSqs(parseInt(e.target.value))} />\r\n        <input type='text' title='speed' style={inputCssTiny} value={currentAddingIconSpeed} onChange={(e) => setCurrentAddingIconSpeed(parseInt(e.target.value))} />\r\n        <input type='text' title='add icon' style={inputCss} value={currentAddingIcon} onChange={(e) => setCurrentAddingIcon(e.target.value)} />\r\n        <button onClick={() => addIcon()} >Add</button>\r\n\r\n        <br />\r\n        <Battlemap initialIcons={icons} boardHeight={height} boardWidth={width} />\r\n    </>;\r\n}\r\n\r\n\r\nexport default Battleview;"],"sourceRoot":""}